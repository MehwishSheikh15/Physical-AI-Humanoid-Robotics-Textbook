"use strict";(globalThis.webpackChunkai_robotics_book=globalThis.webpackChunkai_robotics_book||[]).push([[5072],{5709:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Module-2-GAZEBO/week-06-gazebo-fundamentals","title":"Week 6: Robot Simulation Fundamentals with Gazebo","description":"Learn to build virtual robot worlds with Gazebo, simulate physics, and integrate sensors for safe algorithm testing before hardware deployment.","source":"@site/docs/Module-2-GAZEBO/week-06-gazebo-fundamentals.mdx","sourceDirName":"Module-2-GAZEBO","slug":"/Module-2-GAZEBO/week-06-gazebo-fundamentals","permalink":"/ai-robotics-book/docs/Module-2-GAZEBO/week-06-gazebo-fundamentals","draft":false,"unlisted":false,"editUrl":"https://github.com/ai-robotics/ai-robotics-book/tree/main/docs/Module-2-GAZEBO/week-06-gazebo-fundamentals.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Week 6: Robot Simulation Fundamentals with Gazebo","description":"Learn to build virtual robot worlds with Gazebo, simulate physics, and integrate sensors for safe algorithm testing before hardware deployment."},"sidebar":"tutorialSidebar","previous":{"title":"Week 5: ROS 2 Advanced Patterns","permalink":"/ai-robotics-book/docs/Module-1-ROS2/week-05-ros2-advanced"},"next":{"title":"Week 6: Robot Simulation Fundamentals with Gazebo","permalink":"/ai-robotics-book/docs/Module-2-GAZEBO/week-06-gazebo-fundamentals"}}');var o=s(4848),r=s(8453);const a={sidebar_position:6,title:"Week 6: Robot Simulation Fundamentals with Gazebo",description:"Learn to build virtual robot worlds with Gazebo, simulate physics, and integrate sensors for safe algorithm testing before hardware deployment."},t="Week 6: Robot Simulation Fundamentals with Gazebo",l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Gazebo vs Gazebo Ignition (Fortress)",id:"gazebo-vs-gazebo-ignition-fortress",level:2},{value:"Two Versions, One Ecosystem",id:"two-versions-one-ecosystem",level:3},{value:"Installation",id:"installation",level:3},{value:"Creating Your First World",id:"creating-your-first-world",level:2},{value:"World File Structure (SDF)",id:"world-file-structure-sdf",level:3},{value:"Launching Your World",id:"launching-your-world",level:3},{value:"Adding Objects and Models",id:"adding-objects-and-models",level:2},{value:"Spawning Basic Shapes",id:"spawning-basic-shapes",level:3},{value:"Using Model Database",id:"using-model-database",level:3},{value:"Physics Engine Configuration",id:"physics-engine-configuration",level:2},{value:"Choosing a Physics Engine",id:"choosing-a-physics-engine",level:3},{value:"Tuning Physics Parameters",id:"tuning-physics-parameters",level:3},{value:"Adding Sensors",id:"adding-sensors",level:2},{value:"Camera Sensor",id:"camera-sensor",level:3},{value:"LIDAR Sensor (2D/3D)",id:"lidar-sensor-2d3d",level:3},{value:"IMU Sensor",id:"imu-sensor",level:3},{value:"ROS 2 Integration with ros_gz_bridge",id:"ros-2-integration-with-ros_gz_bridge",level:2},{value:"Bridging Gazebo Topics to ROS 2",id:"bridging-gazebo-topics-to-ros-2",level:3},{value:"Sending Commands from ROS 2 to Gazebo",id:"sending-commands-from-ros-2-to-gazebo",level:3},{value:"Code Example: Teleoperation in Simulation",id:"code-example-teleoperation-in-simulation",level:2},{value:"Self-Assessment Questions",id:"self-assessment-questions",level:2},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"week-6-robot-simulation-fundamentals-with-gazebo",children:"Week 6: Robot Simulation Fundamentals with Gazebo"})}),"\n",(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsxs)(n.p,{children:["Testing robotics algorithms on real hardware is expensive, time-consuming, and risky. A single bug in your navigation code could send a $50,000 robot crashing into a wall. ",(0,o.jsx)(n.strong,{children:"Simulation"})," solves this by creating virtual environments where you can test, iterate, and break things without consequences."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Gazebo"})," is the industry-standard robot simulator, offering photorealistic 3D rendering, accurate physics simulation, and seamless ROS 2 integration. From autonomous vehicles to humanoid robots, Gazebo enables rapid prototyping and validation before hardware deployment."]}),"\n",(0,o.jsx)(n.p,{children:"This week, you'll create your first Gazebo world, spawn robots, configure physics engines, add sensors (cameras, LIDAR), and integrate everything with ROS 2. By the end, you'll have a complete simulation pipeline for testing algorithms in safe, repeatable virtual environments."}),"\n",(0,o.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(n.p,{children:"By the end of this week, you will be able to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Set up"})," Gazebo Classic and Gazebo Fortress/Ignition for ROS 2 Humble"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Create"})," custom world files with terrain, lighting, and environmental objects"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Configure"})," physics engines (ODE, Bullet, Dart) and tune simulation parameters"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Add"})," sensor plugins (camera, LIDAR, IMU) to simulated robots"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Integrate"})," Gazebo with ROS 2 using ros_gz_bridge for topic communication"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"gazebo-vs-gazebo-ignition-fortress",children:"Gazebo vs Gazebo Ignition (Fortress)"}),"\n",(0,o.jsx)(n.h3,{id:"two-versions-one-ecosystem",children:"Two Versions, One Ecosystem"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Gazebo Classic"})," (v11): Older, stable, widely used, good documentation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Gazebo Fortress/Garden/Harmonic"}),' (formerly "Ignition"): Modern rewrite, better performance, modular architecture']}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["For ROS 2 Humble, ",(0,o.jsx)(n.strong,{children:"Gazebo Fortress"})," is recommended, but Gazebo Classic still works. We'll focus on ",(0,o.jsx)(n.strong,{children:"Gazebo Fortress"}),' (now officially called "Gazebo" as of 2022).']}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mermaid",children:'graph TB\n    subgraph "Gazebo Simulation Stack"\n        ROS2["ROS 2 Nodes<br/>(Your Code)"]\n        Bridge["ros_gz_bridge<br/>(ROS \u2194 Gazebo)"]\n        Gazebo["Gazebo Sim<br/>(Physics Engine)"]\n        Plugins["Sensor Plugins<br/>(Camera, LIDAR, IMU)"]\n        Renderer["Rendering Engine<br/>(OGRE 2)"]\n    end\n\n    ROS2 --\x3e|Topics/Services| Bridge\n    Bridge --\x3e|gz::msgs| Gazebo\n    Gazebo --\x3e Plugins\n    Gazebo --\x3e Renderer\n    Plugins --\x3e|Sensor Data| Bridge\n\n    style Gazebo fill:#a855f7,stroke:#9333ea,stroke-width:2px,color:#fff\n    style Bridge fill:#ec4899,stroke:#db2777,stroke-width:2px,color:#fff\n    style Renderer fill:#06b6d4,stroke:#0891b2,stroke-width:2px,color:#fff\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Diagram:"})," Gazebo simulation architecture showing integration with ROS 2 through the bridge, physics simulation, sensor plugins, and rendering."]}),"\n",(0,o.jsx)(n.h3,{id:"installation",children:"Installation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'# Install Gazebo Fortress (for ROS 2 Humble)\nsudo apt install ros-humble-ros-gz\n\n# Install Gazebo Classic (alternative)\nsudo apt install ros-humble-gazebo-ros-pkgs\n\n# Verify installation\ngz sim --version  # Should show "Gazebo Sim, version X.X.X"\n\n# Test Gazebo\ngz sim shapes.sdf  # Launches demo world with basic shapes\n'})}),"\n",(0,o.jsx)(n.h2,{id:"creating-your-first-world",children:"Creating Your First World"}),"\n",(0,o.jsx)(n.h3,{id:"world-file-structure-sdf",children:"World File Structure (SDF)"}),"\n",(0,o.jsxs)(n.p,{children:["Gazebo uses ",(0,o.jsx)(n.strong,{children:"SDF (Simulation Description Format)"})," for world and model definitions. Create ",(0,o.jsx)(n.code,{children:"worlds/empty_world.sdf"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.8">\n  <world name="empty_world">\n\n    \x3c!-- Physics engine configuration --\x3e\n    <physics name="1ms" type="ignored">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1</real_time_factor>\n    </physics>\n\n    \x3c!-- Plugins for ROS 2 integration --\x3e\n    <plugin filename="libignition-gazebo-physics-system.so" name="ignition::gazebo::systems::Physics"/>\n    <plugin filename="libignition-gazebo-user-commands-system.so" name="ignition::gazebo::systems::UserCommands"/>\n    <plugin filename="libignition-gazebo-scene-broadcaster-system.so" name="ignition::gazebo::systems::SceneBroadcaster"/>\n\n    \x3c!-- Lighting --\x3e\n    <light type="directional" name="sun">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.5 0.1 -0.9</direction>\n    </light>\n\n    \x3c!-- Ground plane --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.8 0.8 0.8 1</ambient>\n            <diffuse>0.8 0.8 0.8 1</diffuse>\n            <specular>0.8 0.8 0.8 1</specular>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"launching-your-world",children:"Launching Your World"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"gz sim empty_world.sdf\n"})}),"\n",(0,o.jsx)(n.p,{children:"You should see a 3D window with a gray ground plane and directional lighting."}),"\n",(0,o.jsx)(n.h2,{id:"adding-objects-and-models",children:"Adding Objects and Models"}),"\n",(0,o.jsx)(n.h3,{id:"spawning-basic-shapes",children:"Spawning Basic Shapes"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Add this inside <world> tag --\x3e\n<model name="box">\n  <pose>0 0 0.5 0 0 0</pose>  \x3c!-- x y z roll pitch yaw --\x3e\n  <link name="box_link">\n    <collision name="collision">\n      <geometry>\n        <box>\n          <size>1 1 1</size>  \x3c!-- 1m cube --\x3e\n        </box>\n      </geometry>\n    </collision>\n    <visual name="visual">\n      <geometry>\n        <box>\n          <size>1 1 1</size>\n        </box>\n      </geometry>\n      <material>\n        <ambient>1 0 0 1</ambient>  \x3c!-- Red color --\x3e\n        <diffuse>1 0 0 1</diffuse>\n      </material>\n    </visual>\n    \x3c!-- Make it dynamic (affected by physics) --\x3e\n    <inertial>\n      <mass>10</mass>\n      <inertia>\n        <ixx>1.67</ixx>\n        <iyy>1.67</iyy>\n        <izz>1.67</izz>\n      </inertia>\n    </inertial>\n  </link>\n</model>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"using-model-database",children:"Using Model Database"}),"\n",(0,o.jsx)(n.p,{children:"Gazebo has a built-in model database (or you can use Fuel, the online repository):"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Include a model from the database --\x3e\n<include>\n  <uri>https://fuel.ignitionrobotics.org/1.0/OpenRobotics/models/Cafe</uri>\n  <pose>5 5 0 0 0 0</pose>\n</include>\n"})}),"\n",(0,o.jsx)(n.h2,{id:"physics-engine-configuration",children:"Physics Engine Configuration"}),"\n",(0,o.jsx)(n.h3,{id:"choosing-a-physics-engine",children:"Choosing a Physics Engine"}),"\n",(0,o.jsx)(n.p,{children:"Gazebo supports multiple physics backends:"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Engine"}),(0,o.jsx)(n.th,{children:"Pros"}),(0,o.jsx)(n.th,{children:"Cons"}),(0,o.jsx)(n.th,{children:"Use Case"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"ODE"})}),(0,o.jsx)(n.td,{children:"Fast, stable, default"}),(0,o.jsx)(n.td,{children:"Less accurate contacts"}),(0,o.jsx)(n.td,{children:"General robotics"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Bullet"})}),(0,o.jsx)(n.td,{children:"Fast, good for soft bodies"}),(0,o.jsx)(n.td,{children:"Less deterministic"}),(0,o.jsx)(n.td,{children:"Deformable objects"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"DART"})}),(0,o.jsx)(n.td,{children:"Accurate, handles complex constraints"}),(0,o.jsx)(n.td,{children:"Slower"}),(0,o.jsx)(n.td,{children:"Manipulation, humanoids"})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"tuning-physics-parameters",children:"Tuning Physics Parameters"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<physics name="1ms" type="ode">  \x3c!-- or "bullet", "dart" --\x3e\n  <max_step_size>0.001</max_step_size>  \x3c!-- 1ms time steps --\x3e\n  <real_time_factor>1</real_time_factor>  \x3c!-- 1x speed (real-time) --\x3e\n\n  \x3c!-- ODE-specific settings --\x3e\n  <ode>\n    <solver>\n      <type>quick</type>  \x3c!-- "quick" or "world" --\x3e\n      <iters>50</iters>  \x3c!-- Solver iterations (higher = more accurate) --\x3e\n      <sor>1.3</sor>  \x3c!-- Successive over-relaxation --\x3e\n    </solver>\n    <constraints>\n      <cfm>0</cfm>  \x3c!-- Constraint force mixing (softness) --\x3e\n      <erp>0.2</erp>  \x3c!-- Error reduction parameter (how fast to correct errors) --\x3e\n      <contact_max_correcting_vel>100</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsxs)(n.p,{children:["Smaller ",(0,o.jsx)(n.code,{children:"max_step_size"})," increases accuracy but slows simulation. Start with 0.001 (1ms). For fast robots or precise manipulation, use 0.0005 (0.5ms). For slower systems, 0.01 (10ms) is acceptable."]})}),"\n",(0,o.jsx)(n.h2,{id:"adding-sensors",children:"Adding Sensors"}),"\n",(0,o.jsx)(n.h3,{id:"camera-sensor",children:"Camera Sensor"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<sensor name="camera" type="camera">\n  <camera>\n    <horizontal_fov>1.047</horizontal_fov>  \x3c!-- 60 degrees --\x3e\n    <image>\n      <width>1920</width>\n      <height>1080</height>\n      <format>R8G8B8</format>  \x3c!-- RGB --\x3e\n    </image>\n    <clip>\n      <near>0.1</near>\n      <far>100</far>\n    </clip>\n  </camera>\n  <always_on>1</always_on>\n  <update_rate>30</update_rate>\n  <visualize>true</visualize>  \x3c!-- Show camera frustum in GUI --\x3e\n\n  \x3c!-- Topic publishing plugin --\x3e\n  <plugin filename="libignition-gazebo-camera-system.so" name="ignition::gazebo::systems::Camera"/>\n</sensor>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"lidar-sensor-2d3d",children:"LIDAR Sensor (2D/3D)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<sensor name="lidar" type="gpu_lidar">\n  <pose>0 0 0.5 0 0 0</pose>\n  <lidar>\n    <scan>\n      <horizontal>\n        <samples>640</samples>  \x3c!-- Number of beams --\x3e\n        <resolution>1</resolution>\n        <min_angle>-1.57</min_angle>  \x3c!-- -90 degrees --\x3e\n        <max_angle>1.57</max_angle>   \x3c!-- +90 degrees --\x3e\n      </horizontal>\n      <vertical>\n        <samples>16</samples>  \x3c!-- 16 vertical layers (3D LIDAR) --\x3e\n        <resolution>1</resolution>\n        <min_angle>-0.26</min_angle>  \x3c!-- -15 degrees --\x3e\n        <max_angle>0.26</max_angle>   \x3c!-- +15 degrees --\x3e\n      </vertical>\n    </scan>\n    <range>\n      <min>0.1</min>\n      <max>30.0</max>\n      <resolution>0.01</resolution>\n    </range>\n  </lidar>\n  <always_on>1</always_on>\n  <update_rate>10</update_rate>\n  <visualize>true</visualize>\n\n  <plugin filename="libignition-gazebo-lidar-system.so" name="ignition::gazebo::systems::Lidar"/>\n</sensor>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"imu-sensor",children:"IMU Sensor"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<sensor name="imu" type="imu">\n  <always_on>1</always_on>\n  <update_rate>100</update_rate>  \x3c!-- 100 Hz --\x3e\n  <imu>\n    <angular_velocity>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.0002</stddev>\n        </noise>\n      </x>\n      <y>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.0002</stddev>\n        </noise>\n      </y>\n      <z>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.0002</stddev>\n        </noise>\n      </z>\n    </angular_velocity>\n    <linear_acceleration>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.017</stddev>\n        </noise>\n      </x>\n      <y>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.017</stddev>\n        </noise>\n      </y>\n      <z>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.017</stddev>\n        </noise>\n      </z>\n    </linear_acceleration>\n  </imu>\n\n  <plugin filename="libignition-gazebo-imu-system.so" name="ignition::gazebo::systems::Imu"/>\n</sensor>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"ros-2-integration-with-ros_gz_bridge",children:"ROS 2 Integration with ros_gz_bridge"}),"\n",(0,o.jsx)(n.h3,{id:"bridging-gazebo-topics-to-ros-2",children:"Bridging Gazebo Topics to ROS 2"}),"\n",(0,o.jsx)(n.p,{children:"Gazebo publishes sensor data on its own topics (Ignition Transport). To use them in ROS 2, we need a bridge:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# launch/gazebo_ros2_bridge.launch.py\n\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        # Bridge camera topic\n        Node(\n            package='ros_gz_bridge',\n            executable='parameter_bridge',\n            arguments=[\n                '/camera@sensor_msgs/msg/Image[ignition.msgs.Image',\n                '/camera_info@sensor_msgs/msg/CameraInfo[ignition.msgs.CameraInfo',\n            ],\n            output='screen'\n        ),\n\n        # Bridge LIDAR topic\n        Node(\n            package='ros_gz_bridge',\n            executable='parameter_bridge',\n            arguments=[\n                '/lidar@sensor_msgs/msg/LaserScan[ignition.msgs.LaserScan',\n            ],\n            output='screen'\n        ),\n\n        # Bridge IMU topic\n        Node(\n            package='ros_gz_bridge',\n            executable='parameter_bridge',\n            arguments=[\n                '/imu@sensor_msgs/msg/Imu[ignition.msgs.IMU',\n            ],\n            output='screen'\n        ),\n    ])\n"})}),"\n",(0,o.jsx)(n.p,{children:"Now sensor data appears on ROS 2 topics:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"ros2 topic list\n# Output:\n# /camera\n# /camera_info\n# /lidar\n# /imu\n# ...\n\nros2 topic echo /lidar\n"})}),"\n",(0,o.jsx)(n.h3,{id:"sending-commands-from-ros-2-to-gazebo",children:"Sending Commands from ROS 2 to Gazebo"}),"\n",(0,o.jsx)(n.p,{children:"To control a robot, bridge command topics:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Bidirectional bridge for velocity commands\nNode(\n    package='ros_gz_bridge',\n    executable='parameter_bridge',\n    arguments=[\n        '/cmd_vel@geometry_msgs/msg/Twist]ignition.msgs.Twist',\n    ],\n    output='screen'\n),\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Now you can publish to ",(0,o.jsx)(n.code,{children:"/cmd_vel"})," from ROS 2 and the robot in Gazebo will move!"]}),"\n",(0,o.jsx)(n.h2,{id:"code-example-teleoperation-in-simulation",children:"Code Example: Teleoperation in Simulation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nimport sys\nimport termios\nimport tty\n\n\nclass TeleopKey(Node):\n    def __init__(self):\n        super().__init__('teleop_key')\n\n        self.publisher_ = self.create_publisher(Twist, '/cmd_vel', 10)\n\n        self.get_logger().info('Teleop started. Use WASD to move, Q to quit.')\n\n        self.settings = termios.tcgetattr(sys.stdin)\n        self.run()\n\n    def get_key(self):\n        tty.setraw(sys.stdin.fileno())\n        key = sys.stdin.read(1)\n        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.settings)\n        return key\n\n    def run(self):\n        try:\n            while rclpy.ok():\n                key = self.get_key()\n\n                twist = Twist()\n\n                if key == 'w':\n                    twist.linear.x = 0.5  # Forward\n                elif key == 's':\n                    twist.linear.x = -0.5  # Backward\n                elif key == 'a':\n                    twist.angular.z = 0.5  # Turn left\n                elif key == 'd':\n                    twist.angular.z = -0.5  # Turn right\n                elif key == 'q':\n                    break\n\n                self.publisher_.publish(twist)\n\n        finally:\n            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.settings)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = TeleopKey()\n    node.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"self-assessment-questions",children:"Self-Assessment Questions"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.strong,{children:["What is the purpose of the ",(0,o.jsx)(n.code,{children:"max_step_size"})," parameter in Gazebo physics configuration?"]})}),"\n",(0,o.jsx)(s,{children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)("summary",{children:"Answer"}),"\n",(0,o.jsx)(n.code,{children:"max_step_size"})," defines the time step for physics simulation (in seconds). Smaller values (e.g., 0.001s = 1ms) increase accuracy but require more computation. Larger values (e.g., 0.01s = 10ms) run faster but may miss fast collisions or introduce instability. For robots with fast dynamics (quadcopters, high-speed wheels), use 1ms or smaller. For slow robots, 10ms is acceptable."]})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Why do we need ros_gz_bridge instead of directly using Gazebo topics in ROS 2?"})}),"\n",(0,o.jsx)(s,{children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)("summary",{children:"Answer"}),"\nGazebo uses its own middleware (Ignition Transport) which is separate from ROS 2's DDS middleware. The two systems cannot directly communicate. ",(0,o.jsx)(n.code,{children:"ros_gz_bridge"})," translates messages between Ignition Transport topics and ROS 2 topics, allowing sensor data from Gazebo (e.g., camera images) to be published as ROS 2 messages that other ROS 2 nodes can subscribe to. Without the bridge, ROS 2 nodes wouldn't see Gazebo's sensor data."]})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"How does adding Gaussian noise to an IMU sensor in simulation help prepare for real-world deployment?"})}),"\n",(0,o.jsx)(s,{children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)("summary",{children:"Answer"}),"\nReal IMUs have noise due to electronic interference, thermal drift, and manufacturing imperfections. Algorithms tested only on perfect simulated IMU data often fail on real hardware because they don't handle noise. By adding realistic noise models (Gaussian with appropriate mean/stddev based on real sensor specs), algorithms learn to be robust\u2014e.g., using filtering (Kalman filter) to smooth noisy data. This reduces the sim-to-real gap."]})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.strong,{children:["What is the difference between ",(0,o.jsx)(n.code,{children:"<collision>"})," and ",(0,o.jsx)(n.code,{children:"<visual>"})," geometries in SDF?"]})}),"\n",(0,o.jsx)(s,{children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)("summary",{children:"Answer"}),"\n",(0,o.jsx)(n.code,{children:"<collision>"})," defines the shape used for physics calculations (contact detection, collisions). ",(0,o.jsx)(n.code,{children:"<visual>"})," defines the shape rendered in the 3D view. They can differ: for performance, collision geometry is often simpler (e.g., a box approximating a detailed mesh). For example, a robot might have a detailed visual mesh for realism but use simple collision boxes for faster physics computation. Complex collision geometry slows down simulation significantly."]})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"When would you choose DART physics engine over ODE?"})}),"\n",(0,o.jsx)(s,{children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)("summary",{children:"Answer"}),"\nChoose DART when you need: (1) highly accurate contact dynamics for manipulation (grasping, pushing), (2) complex kinematic constraints (closed loops, parallel mechanisms), or (3) humanoid robotics with many joints and contacts (bipedal walking). DART is more accurate but slower than ODE. Use ODE for faster simulation when accuracy requirements are moderate, such as wheeled robots or aerial vehicles where contact dynamics are less critical."]})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"This week, you learned the fundamentals of robot simulation with Gazebo:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Gazebo Fortress"})," is the modern simulator integrated with ROS 2 Humble"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"SDF files"})," define worlds, models, physics, and sensors"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Physics engines"})," (ODE, Bullet, DART) can be tuned for accuracy vs speed"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sensors"})," (camera, LIDAR, IMU) can be added with plugins"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ros_gz_bridge"})," connects Gazebo topics to ROS 2 for seamless integration"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsxs)(n.p,{children:["In Week 7, we dive deeper into ",(0,o.jsx)(n.strong,{children:"URDF Modeling and Simulation"}),", where you'll create custom robot models with joints, links, and sensors. You'll learn URDF syntax, XACRO macros for modularity, and integrate your robot models with Gazebo and RViz for visualization."]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>t});var i=s(6540);const o={},r=i.createContext(o);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);