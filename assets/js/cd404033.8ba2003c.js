"use strict";(globalThis.webpackChunkai_robotics_book=globalThis.webpackChunkai_robotics_book||[]).push([[3200],{7887:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Module-2-GAZEBO/week-07-urdf-modeling","title":"Week 7: URDF Modeling and Simulation","description":"Create custom robot models using URDF and XACRO, define joints and links, integrate sensors, and visualize in RViz and Gazebo.","source":"@site/docs/Module-2-GAZEBO/week-07-urdf-modeling.mdx","sourceDirName":"Module-2-GAZEBO","slug":"/Module-2-GAZEBO/week-07-urdf-modeling","permalink":"/ai-robotics-book/docs/Module-2-GAZEBO/week-07-urdf-modeling","draft":false,"unlisted":false,"editUrl":"https://github.com/ai-robotics/ai-robotics-book/tree/main/docs/Module-2-GAZEBO/week-07-urdf-modeling.mdx","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"Week 7: URDF Modeling and Simulation","description":"Create custom robot models using URDF and XACRO, define joints and links, integrate sensors, and visualize in RViz and Gazebo."},"sidebar":"tutorialSidebar","previous":{"title":"Week 6: Robot Simulation Fundamentals with Gazebo","permalink":"/ai-robotics-book/docs/Module-2-GAZEBO/week-06-gazebo-fundamentals"},"next":{"title":"Week 8: NVIDIA Isaac Platform Introduction","permalink":"/ai-robotics-book/docs/Module-3-ISSAC/week-08-isaac-intro"}}');var r=i(4848),o=i(8453);const a={sidebar_position:7,title:"Week 7: URDF Modeling and Simulation",description:"Create custom robot models using URDF and XACRO, define joints and links, integrate sensors, and visualize in RViz and Gazebo."},t="Week 7: URDF Modeling and Simulation",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"URDF Fundamentals",id:"urdf-fundamentals",level:2},{value:"Core Concepts",id:"core-concepts",level:3},{value:"Minimal URDF Example",id:"minimal-urdf-example",level:3},{value:"Joint Types",id:"joint-types",level:3},{value:"Using XACRO for Modularity",id:"using-xacro-for-modularity",level:2},{value:"Why XACRO?",id:"why-xacro",level:3},{value:"XACRO Example: Parameterized Wheel",id:"xacro-example-parameterized-wheel",level:3},{value:"Converting XACRO to URDF",id:"converting-xacro-to-urdf",level:3},{value:"Calculating Inertial Properties",id:"calculating-inertial-properties",level:2},{value:"Why Accurate Inertia Matters",id:"why-accurate-inertia-matters",level:3},{value:"Inertia Formulas for Common Shapes",id:"inertia-formulas-for-common-shapes",level:3},{value:"Adding Sensors to URDF",id:"adding-sensors-to-urdf",level:2},{value:"Camera Sensor",id:"camera-sensor",level:3},{value:"LIDAR Sensor",id:"lidar-sensor",level:3},{value:"Visualizing in RViz",id:"visualizing-in-rviz",level:2},{value:"Publishing Robot State",id:"publishing-robot-state",level:3},{value:"Simulating in Gazebo",id:"simulating-in-gazebo",level:2},{value:"Gazebo Launch File",id:"gazebo-launch-file",level:3},{value:"Self-Assessment Questions",id:"self-assessment-questions",level:2},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"week-7-urdf-modeling-and-simulation",children:"Week 7: URDF Modeling and Simulation"})}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:["Every robot needs a digital twin\u2014a precise 3D model describing its physical structure, sensor placements, and motion capabilities. ",(0,r.jsx)("span",{className:"highlight-purple",children:(0,r.jsx)(n.strong,{children:"URDF (Unified Robot Description Format)"})})," is the standard language for defining robot models in ROS."]}),"\n",(0,r.jsxs)(n.p,{children:["Whether you're building a wheeled rover, manipulator arm, or humanoid robot, URDF captures the geometry, kinematics, dynamics, and sensor configuration. Combined with ",(0,r.jsx)(n.strong,{children:"XACRO"})," (XML Macros), you can create modular, reusable robot descriptions that scale from simple prototypes to complex systems."]}),"\n",(0,r.jsx)(n.p,{children:"This week, you'll master URDF syntax, create a mobile robot from scratch, add sensors, visualize in RViz, simulate in Gazebo, and learn best practices for maintainable robot models."}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this week, you will be able to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Define"})," robot models using URDF with links, joints, and collision/visual geometries"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use"})," XACRO macros to create reusable, parameterized robot components"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Calculate"})," inertial properties for realistic physics simulation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Integrate"})," sensors (cameras, LIDAR) into URDF models"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Visualize"})," robots in RViz and simulate in Gazebo with proper physics"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"urdf-fundamentals",children:"URDF Fundamentals"}),"\n",(0,r.jsx)(n.h3,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,r.jsxs)(n.p,{children:["A robot in URDF is a tree structure of ",(0,r.jsx)(n.strong,{children:"links"})," connected by ",(0,r.jsx)(n.strong,{children:"joints"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Link"}),": A rigid body (wheel, arm segment, sensor mount)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Joint"}),": Connection between two links (revolute, continuous, prismatic, fixed)"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:'graph TB\n    Base["base_link<br/>(Chassis)"]\n    WheelL["wheel_left_link"]\n    WheelR["wheel_right_link"]\n    Camera["camera_link"]\n    LIDAR["lidar_link"]\n\n    Base --\x3e|continuous<br/>joint| WheelL\n    Base --\x3e|continuous<br/>joint| WheelR\n    Base --\x3e|fixed<br/>joint| Camera\n    Base --\x3e|fixed<br/>joint| LIDAR\n\n    subgraph "Link Components"\n        Visual["Visual<br/>(Appearance)"]\n        Collision["Collision<br/>(Physics)"]\n        Inertial["Inertial<br/>(Mass, Inertia)"]\n    end\n\n    style Base fill:#a855f7,stroke:#9333ea,stroke-width:2px,color:#fff\n    style WheelL fill:#ec4899,stroke:#db2777,stroke-width:2px,color:#fff\n    style WheelR fill:#ec4899,stroke:#db2777,stroke-width:2px,color:#fff\n    style Camera fill:#06b6d4,stroke:#0891b2,stroke-width:2px,color:#fff\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Diagram:"})," URDF robot model structure showing base_link connected to wheels (continuous joints) and sensors (fixed joints), with each link containing visual, collision, and inertial properties."]}),"\n",(0,r.jsx)(n.h3,{id:"minimal-urdf-example",children:"Minimal URDF Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_bot">\n\n  \x3c!-- Base link (robot chassis) --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.6 0.4 0.2"/>  \x3c!-- 60cm x 40cm x 20cm --\x3e\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.6 0.4 0.2"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="10"/>  \x3c!-- 10 kg --\x3e\n      <inertia ixx="0.15" ixy="0.0" ixz="0.0"\n               iyy="0.35" iyz="0.0"\n               izz="0.45"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Left wheel --\x3e\n  <link name="wheel_left">\n    <visual>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1"/>\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0"\n               iyy="0.001" iyz="0.0"\n               izz="0.002"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Joint connecting base to left wheel --\x3e\n  <joint name="wheel_left_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="wheel_left"/>\n    <origin xyz="0 0.225 -0.05" rpy="1.5708 0 0"/>  \x3c!-- Position and rotation --\x3e\n    <axis xyz="0 0 1"/>  \x3c!-- Rotation axis (Z-axis in wheel frame) --\x3e\n  </joint>\n\n  \x3c!-- Right wheel (similar structure, omitted for brevity) --\x3e\n\n</robot>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"joint-types",children:"Joint Types"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Description"}),(0,r.jsx)(n.th,{children:"Use Case"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"fixed"})}),(0,r.jsx)(n.td,{children:"No movement"}),(0,r.jsx)(n.td,{children:"Attach sensors, static mounts"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"revolute"})}),(0,r.jsx)(n.td,{children:"Rotates around axis with limits"}),(0,r.jsx)(n.td,{children:"Robot arm joints"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"continuous"})}),(0,r.jsx)(n.td,{children:"Rotates indefinitely"}),(0,r.jsx)(n.td,{children:"Wheels, spinning sensors"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"prismatic"})}),(0,r.jsx)(n.td,{children:"Slides along axis"}),(0,r.jsx)(n.td,{children:"Linear actuators, lifts"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"floating"})}),(0,r.jsx)(n.td,{children:"6-DoF free movement"}),(0,r.jsx)(n.td,{children:"Rarely used (flying robots)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"planar"})}),(0,r.jsx)(n.td,{children:"Moves in a plane"}),(0,r.jsx)(n.td,{children:"Rarely used"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"using-xacro-for-modularity",children:"Using XACRO for Modularity"}),"\n",(0,r.jsx)(n.h3,{id:"why-xacro",children:"Why XACRO?"}),"\n",(0,r.jsxs)(n.p,{children:["Pure URDF becomes repetitive for symmetric structures (wheels, legs). ",(0,r.jsx)("span",{className:"highlight-purple",children:(0,r.jsx)(n.strong,{children:"XACRO"})})," adds:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Properties"}),": Variables (constants)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macros"}),": Reusable templates"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Math"}),": Calculations (e.g., ",(0,r.jsx)(n.code,{children:"${PI/2}"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Includes"}),": Split large files"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"xacro-example-parameterized-wheel",children:"XACRO Example: Parameterized Wheel"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="robot_with_xacro">\n\n  \x3c!-- Properties (constants) --\x3e\n  <xacro:property name="wheel_radius" value="0.1"/>\n  <xacro:property name="wheel_length" value="0.05"/>\n  <xacro:property name="wheel_mass" value="1.0"/>\n\n  \x3c!-- Macro for creating a wheel --\x3e\n  <xacro:macro name="wheel" params="prefix reflect">\n    <link name="wheel_${prefix}">\n      <visual>\n        <geometry>\n          <cylinder radius="${wheel_radius}" length="${wheel_length}"/>\n        </geometry>\n        <material name="black">\n          <color rgba="0 0 0 1"/>\n        </material>\n      </visual>\n      <collision>\n        <geometry>\n          <cylinder radius="${wheel_radius}" length="${wheel_length}"/>\n        </geometry>\n      </collision>\n      <inertial>\n        <mass value="${wheel_mass}"/>\n        \x3c!-- Cylinder inertia formula: I = m*r^2/2 --\x3e\n        <inertia ixx="${wheel_mass * wheel_radius * wheel_radius / 2.0}"\n                 ixy="0.0" ixz="0.0"\n                 iyy="${wheel_mass * wheel_radius * wheel_radius / 2.0}"\n                 iyz="0.0"\n                 izz="${wheel_mass * wheel_radius * wheel_radius / 2.0}"/>\n      </inertial>\n    </link>\n\n    <joint name="wheel_${prefix}_joint" type="continuous">\n      <parent link="base_link"/>\n      <child link="wheel_${prefix}"/>\n      \x3c!-- reflect = 1 for left, -1 for right (mirror position) --\x3e\n      <origin xyz="0 ${reflect * 0.225} -0.05" rpy="1.5708 0 0"/>\n      <axis xyz="0 0 1"/>\n    </joint>\n  </xacro:macro>\n\n  \x3c!-- Use the macro to create left and right wheels --\x3e\n  <xacro:wheel prefix="left" reflect="1"/>\n  <xacro:wheel prefix="right" reflect="-1"/>\n\n</robot>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"converting-xacro-to-urdf",children:"Converting XACRO to URDF"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Process XACRO file to generate pure URDF\nxacro robot.urdf.xacro > robot.urdf\n\n# Or use within a launch file (automatic conversion)\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"Always use XACRO for production robots. It dramatically reduces duplication and makes updating parameters (e.g., wheel radius) trivial\u2014change one property instead of 20 hardcoded values."})}),"\n",(0,r.jsx)(n.h2,{id:"calculating-inertial-properties",children:"Calculating Inertial Properties"}),"\n",(0,r.jsx)(n.h3,{id:"why-accurate-inertia-matters",children:"Why Accurate Inertia Matters"}),"\n",(0,r.jsx)(n.p,{children:"Incorrect inertial values cause unrealistic physics:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Too low mass: Robot floats or flies away"}),"\n",(0,r.jsx)(n.li,{children:"Wrong inertia tensor: Robot wobbles or spins unnaturally"}),"\n",(0,r.jsxs)(n.li,{children:["Missing ",(0,r.jsx)(n.code,{children:"<inertial>"}),": Gazebo treats link as massless (bad!)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"inertia-formulas-for-common-shapes",children:"Inertia Formulas for Common Shapes"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Box"})," (width ",(0,r.jsx)(n.code,{children:"w"}),", depth ",(0,r.jsx)(n.code,{children:"d"}),", height ",(0,r.jsx)(n.code,{children:"h"}),", mass ",(0,r.jsx)(n.code,{children:"m"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<inertia ixx="${m * (h*h + d*d) / 12.0}"\n         iyy="${m * (w*w + d*d) / 12.0}"\n         izz="${m * (w*w + h*h) / 12.0}"\n         ixy="0" ixz="0" iyz="0"/>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cylinder"})," (radius ",(0,r.jsx)(n.code,{children:"r"}),", length ",(0,r.jsx)(n.code,{children:"l"}),", mass ",(0,r.jsx)(n.code,{children:"m"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Cylinder along Z-axis --\x3e\n<inertia ixx="${m * (3*r*r + l*l) / 12.0}"\n         iyy="${m * (3*r*r + l*l) / 12.0}"\n         izz="${m * r*r / 2.0}"\n         ixy="0" ixz="0" iyz="0"/>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Sphere"})," (radius ",(0,r.jsx)(n.code,{children:"r"}),", mass ",(0,r.jsx)(n.code,{children:"m"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<inertia ixx="${2 * m * r*r / 5.0}"\n         iyy="${2 * m * r*r / 5.0}"\n         izz="${2 * m * r*r / 5.0}"\n         ixy="0" ixz="0" iyz="0"/>\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["Use meshes (",(0,r.jsx)(n.code,{children:".stl"}),", ",(0,r.jsx)(n.code,{children:".dae"}),") for complex shapes, but simplify collision geometry. Detailed collision meshes slow simulation. Visual geometry can be detailed; collision should be simple primitives (boxes, cylinders)."]})}),"\n",(0,r.jsx)(n.h2,{id:"adding-sensors-to-urdf",children:"Adding Sensors to URDF"}),"\n",(0,r.jsx)(n.h3,{id:"camera-sensor",children:"Camera Sensor"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Camera link --\x3e\n<link name="camera_link">\n  <visual>\n    <geometry>\n      <box size="0.05 0.05 0.05"/>\n    </geometry>\n  </visual>\n  <collision>\n    <geometry>\n      <box size="0.05 0.05 0.05"/>\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="0.1"/>\n    <inertia ixx="0.0001" ixy="0" ixz="0" iyy="0.0001" iyz="0" izz="0.0001"/>\n  </inertial>\n</link>\n\n\x3c!-- Joint to attach camera to base --\x3e\n<joint name="camera_joint" type="fixed">\n  <parent link="base_link"/>\n  <child link="camera_link"/>\n  <origin xyz="0.3 0 0.1" rpy="0 0 0"/>  \x3c!-- Front of robot, looking forward --\x3e\n</joint>\n\n\x3c!-- Gazebo plugin for camera --\x3e\n<gazebo reference="camera_link">\n  <sensor type="camera" name="camera">\n    <update_rate>30.0</update_rate>\n    <camera name="front_camera">\n      <horizontal_fov>1.3962634</horizontal_fov>  \x3c!-- 80 degrees --\x3e\n      <image>\n        <width>1920</width>\n        <height>1080</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.02</near>\n        <far>300</far>\n      </clip>\n    </camera>\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n      <ros>\n        <namespace>/robot</namespace>\n        <remapping>image_raw:=camera/image</remapping>\n        <remapping>camera_info:=camera/info</remapping>\n      </ros>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"lidar-sensor",children:"LIDAR Sensor"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- LIDAR link --\x3e\n<link name="lidar_link">\n  <visual>\n    <geometry>\n      <cylinder radius="0.05" length="0.07"/>\n    </geometry>\n  </visual>\n  <inertial>\n    <mass value="0.2"/>\n    <inertia ixx="0.0001" ixy="0" ixz="0" iyy="0.0001" iyz="0" izz="0.0001"/>\n  </inertial>\n</link>\n\n<joint name="lidar_joint" type="fixed">\n  <parent link="base_link"/>\n  <child link="lidar_link"/>\n  <origin xyz="0 0 0.2" rpy="0 0 0"/>  \x3c!-- Top of robot --\x3e\n</joint>\n\n<gazebo reference="lidar_link">\n  <sensor type="ray" name="lidar">\n    <pose>0 0 0 0 0 0</pose>\n    <update_rate>10</update_rate>\n    <ray>\n      <scan>\n        <horizontal>\n          <samples>720</samples>\n          <resolution>1</resolution>\n          <min_angle>-3.14159</min_angle>  \x3c!-- -180 degrees --\x3e\n          <max_angle>3.14159</max_angle>   \x3c!-- +180 degrees --\x3e\n        </horizontal>\n      </scan>\n      <range>\n        <min>0.1</min>\n        <max>30.0</max>\n        <resolution>0.01</resolution>\n      </range>\n    </ray>\n    <plugin name="lidar_controller" filename="libgazebo_ros_ray_sensor.so">\n      <ros>\n        <namespace>/robot</namespace>\n        <remapping>~/out:=lidar/scan</remapping>\n      </ros>\n      <output_type>sensor_msgs/LaserScan</output_type>\n      <frame_name>lidar_link</frame_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"visualizing-in-rviz",children:"Visualizing in RViz"}),"\n",(0,r.jsx)(n.h3,{id:"publishing-robot-state",children:"Publishing Robot State"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# launch/robot_state_publisher.launch.py\n\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nimport os\nfrom ament_index_python.packages import get_package_share_directory\n\n\ndef generate_launch_description():\n    urdf_file = os.path.join(\n        get_package_share_directory('my_robot_pkg'),\n        'urdf',\n        'robot.urdf.xacro'\n    )\n\n    return LaunchDescription([\n        # Robot State Publisher (publishes transforms from URDF)\n        Node(\n            package='robot_state_publisher',\n            executable='robot_state_publisher',\n            name='robot_state_publisher',\n            output='screen',\n            parameters=[{'robot_description': open(urdf_file).read()}]\n        ),\n\n        # Joint State Publisher (publishes joint positions)\n        Node(\n            package='joint_state_publisher_gui',\n            executable='joint_state_publisher_gui',\n            name='joint_state_publisher_gui',\n            output='screen'\n        ),\n\n        # RViz\n        Node(\n            package='rviz2',\n            executable='rviz2',\n            name='rviz2',\n            output='screen'\n        ),\n    ])\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"In RViz"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Set Fixed Frame to ",(0,r.jsx)(n.code,{children:"base_link"})]}),"\n",(0,r.jsx)(n.li,{children:"Add \u2192 RobotModel (displays URDF)"}),"\n",(0,r.jsx)(n.li,{children:"Add \u2192 TF (shows coordinate frames)"}),"\n",(0,r.jsx)(n.li,{children:"Use joint_state_publisher_gui sliders to move joints"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"simulating-in-gazebo",children:"Simulating in Gazebo"}),"\n",(0,r.jsx)(n.h3,{id:"gazebo-launch-file",children:"Gazebo Launch File"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# launch/gazebo_spawn.launch.py\n\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch_ros.actions import Node\nimport os\nfrom ament_index_python.packages import get_package_share_directory\n\n\ndef generate_launch_description():\n    pkg_gazebo_ros = get_package_share_directory('gazebo_ros')\n    pkg_my_robot = get_package_share_directory('my_robot_pkg')\n\n    # Gazebo server\n    gzserver = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            os.path.join(pkg_gazebo_ros, 'launch', 'gzserver.launch.py')\n        ),\n        launch_arguments={'world': os.path.join(pkg_my_robot, 'worlds', 'empty_world.world')}.items()\n    )\n\n    # Gazebo client (GUI)\n    gzclient = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            os.path.join(pkg_gazebo_ros, 'launch', 'gzclient.launch.py')\n        )\n    )\n\n    # Spawn robot in Gazebo\n    spawn_robot = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-entity', 'my_robot',\n            '-file', os.path.join(pkg_my_robot, 'urdf', 'robot.urdf'),\n            '-x', '0', '-y', '0', '-z', '0.5'\n        ],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        gzserver,\n        gzclient,\n        spawn_robot,\n    ])\n"})}),"\n",(0,r.jsx)(n.h2,{id:"self-assessment-questions",children:"Self-Assessment Questions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["What is the difference between ",(0,r.jsx)(n.code,{children:"<visual>"})," and ",(0,r.jsx)(n.code,{children:"<collision>"})," geometries in URDF, and why use different geometries?"]})}),"\n",(0,r.jsx)(i,{children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("summary",{children:"Answer"}),"\n",(0,r.jsx)(n.code,{children:"<visual>"})," defines how the link looks in visualization (RViz, Gazebo GUI). ",(0,r.jsx)(n.code,{children:"<collision>"})," defines the shape used for physics collision detection. They can differ because: (1) Visual geometry can be complex meshes for realism without slowing physics, (2) Collision geometry should be simple primitives (boxes, cylinders) for fast physics computation. Example: A robot might have a detailed visual mesh with 10,000 triangles but use a simple box collision shape for 100x faster collision checks."]})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Why is it critical to include ",(0,r.jsx)(n.code,{children:"<inertial>"})," properties for links that will be simulated in Gazebo?"]})}),"\n",(0,r.jsx)(i,{children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("summary",{children:"Answer"}),"\nWithout ",(0,r.jsx)(n.code,{children:"<inertial>"})," properties, Gazebo treats links as massless, causing unrealistic physics: links float, ignore gravity, or behave erratically. Correct mass and inertia tensor values enable realistic dynamics (acceleration, momentum, torque response). Incorrect values lead to unstable simulation (wobbling, flying robots). Always calculate inertia using proper formulas for the shape or use MeshLab/CAD tools to compute from mesh geometry."]})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"How does XACRO's macro feature reduce errors in robot models with symmetric components?"})}),"\n",(0,r.jsx)(i,{children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("summary",{children:"Answer"}),"\nMacros define a component once and instantiate it multiple times with different parameters. For example, a robot with 4 identical wheels: write the wheel macro once, call it 4 times with different positions. If you need to change the wheel radius, you update one property instead of 4 separate link definitions. This prevents copy-paste errors (e.g., forgetting to update one wheel's mass), ensures consistency (all wheels have identical properties), and makes models easier to maintain."]})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["When defining a camera sensor in URDF for Gazebo, why must you specify both the ",(0,r.jsx)(n.code,{children:"<sensor>"})," tag and a Gazebo plugin?"]})}),"\n",(0,r.jsx)(i,{children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("summary",{children:"Answer"}),"\nThe ",(0,r.jsx)(n.code,{children:"<sensor>"})," tag (in ",(0,r.jsx)(n.code,{children:"<gazebo>"})," block) defines the sensor's physical properties (resolution, FOV, update rate). The Gazebo plugin (",(0,r.jsx)(n.code,{children:"libgazebo_ros_camera.so"}),") implements the functionality: it reads the simulated camera pixels and publishes them as ROS 2 messages on topics. Without the sensor definition, there's no camera to simulate. Without the plugin, the data stays in Gazebo and isn't published to ROS 2 topics that your nodes can subscribe to."]})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["What is the purpose of the ",(0,r.jsx)(n.code,{children:"robot_state_publisher"})," node, and when do you need it?"]})}),"\n",(0,r.jsx)(i,{children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("summary",{children:"Answer"}),"\n",(0,r.jsx)(n.code,{children:"robot_state_publisher"})," reads the URDF/XACRO file and the current joint states (from ",(0,r.jsx)(n.code,{children:"/joint_states"})," topic), then publishes TF transforms for all links in the robot. It's needed whenever you want to: (1) Visualize the robot in RViz (RViz needs TF to position each link), (2) Transform sensor data between frames (e.g., camera to base_link), or (3) Use navigation/manipulation stacks that require knowing where each part of the robot is in space. Without it, TF tree is incomplete and many ROS 2 features fail."]})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"This week, you mastered robot modeling with URDF and XACRO:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"URDF"})," defines robot structure with links and joints"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"XACRO"})," adds macros, properties, and math for maintainable models"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inertial properties"})," are critical for realistic physics simulation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensors"})," integrate into URDF via Gazebo plugins"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RViz"})," visualizes robots; ",(0,r.jsx)(n.strong,{children:"Gazebo"})," simulates physics"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.p,{children:["In Week 8, we transition to ",(0,r.jsx)(n.strong,{children:"NVIDIA Isaac Platform Introduction"}),", exploring Isaac Sim for photorealistic simulation, Isaac SDK for perception and navigation, and the powerful synthetic data generation capabilities that make Isaac the go-to platform for industrial Physical AI applications."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>t});var s=i(6540);const r={},o=s.createContext(r);function a(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);